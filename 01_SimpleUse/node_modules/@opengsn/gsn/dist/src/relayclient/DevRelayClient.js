"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RelayClient_1 = __importDefault(require("./RelayClient"));
const RelayServer_1 = __importDefault(require("../relayserver/RelayServer"));
const HttpServer_1 = __importDefault(require("../relayserver/HttpServer"));
const utils_1 = require("../common/utils");
const IStakeManager_1 = __importDefault(require("../common/interfaces/IStakeManager"));
const TxStoreManager_1 = require("../relayserver/TxStoreManager");
const axios_1 = __importDefault(require("axios"));
const net_1 = __importDefault(require("net"));
const KeyManager = require("../relayserver/KeyManager");
const unstakeDelay = 2000;
const TruffleContract = require("@truffle/contract");
// wait for relay until waitFunction return true value, or until a timeout.
async function waitForRelay(url, timeout, waitFunction) {
    const timeoutTime = Date.now() + timeout;
    while (Date.now() <= timeoutTime) {
        let res;
        try {
            res = await axios_1.default.get(url);
        }
        catch (e) {
            res = e;
        }
        const ret = waitFunction(res);
        if (ret != null) {
            return ret;
        }
        await utils_1.sleep(400);
    }
    throw new Error('waitForRelay: timed-out');
}
function runServer(web3provider, relayHub, devConfig) {
    const keyManager = new KeyManager({ count: 2, workdir: devConfig.relayWorkdir });
    const txStoreManager = new TxStoreManager_1.TxStoreManager({ inMemory: true });
    // @ts-ignore
    const relayServer = new RelayServer_1.default({
        web3provider,
        txStoreManager,
        keyManager,
        // owner: relayOwner,
        hubAddress: relayHub,
        url: devConfig.relayUrl,
        baseRelayFee: devConfig.baseRelayFee,
        pctRelayFee: devConfig.pctRelayFee,
        gasPriceFactor: devConfig.gasPriceFactor,
        devMode: devConfig.devMode
    });
    relayServer.on('error', (e) => {
        // console.error('ERR:', e.message)
    });
    const httpServer = new HttpServer_1.default({
        port: devConfig.relayListenPort,
        backend: relayServer
    });
    httpServer.start();
    return {
        httpServer,
        relayServer
    };
}
exports.runServer = runServer;
class DevKnownRelays {
    async getRelaysSortedForTransaction(gsnTransactionDetails) {
        // @ts-ignore
        return Promise.resolve([[this.devRelay]]);
    }
    async refresh() {
    }
    saveRelayFailure(lastErrorTime, relayManager, relayUrl) {
    }
    async getRelayInfoForManagers(relayManagers) {
        return Promise.resolve([]);
    }
}
class DevRelayClient extends RelayClient_1.default {
    constructor(provider, devConfig, overrideDependencies) {
        super(provider, devConfig, Object.assign(Object.assign({}, overrideDependencies), { knownRelaysManager: new DevKnownRelays() }));
        this.serverStarted = false;
        this.devConfig = this.config;
    }
    async relayTransaction(gsnTransactionDetails) {
        await this._initializeRelay();
        return super.relayTransaction(gsnTransactionDetails);
    }
    // stop background relay
    async stopRelay() {
        if (!this.serverStarted) {
            return;
        }
        if (this.httpServer !== undefined) {
            this.httpServer.stop();
            this.httpServer = undefined;
        }
        if (this.relayServer !== undefined) {
            // @ts-ignore
            await this.relayServer.txStoreManager.clearAll();
            this.relayServer.stop();
            this.relayServer = undefined;
        }
    }
    /**
       * initialize a local relay
       * @private
       */
    async _initializeRelay() {
        var _a;
        if (this.serverStarted) {
            return;
        }
        const hub = await this.contractInteractor._createRelayHub(this.config.relayHubAddress);
        const stakeManagerAddress = await hub.getStakeManager();
        let relayListenPort = this.devConfig.relayListenPort;
        // find free port:
        if (relayListenPort === undefined) {
            const server = net_1.default.createServer();
            await new Promise(resolve => {
                server.listen(0, resolve);
            });
            // @ts-ignore
            relayListenPort = server.address().port;
            server.close();
        }
        // eslint-disable-next-line
        const relayUrl = (_a = this.devConfig.relayUrl) !== null && _a !== void 0 ? _a : 'http://localhost:' + relayListenPort.toString();
        // flag early, so only the first call will try to bring up a relay
        // (TODO: other calls should still wait for the relay to start)
        this.serverStarted = true;
        const web3provider = this.contractInteractor.getProvider();
        const { httpServer, relayServer } = await runServer(web3provider, this.config.relayHubAddress, Object.assign(Object.assign({}, this.devConfig), { relayListenPort,
            relayUrl }));
        this.relayServer = relayServer;
        this.httpServer = httpServer;
        // @ts-ignore
        const IStakeManagerContract = TruffleContract({
            contractName: 'IStakeManager',
            abi: IStakeManager_1.default
        });
        IStakeManagerContract.setProvider(this.contractInteractor.getProvider(), undefined);
        const stakeManager = await IStakeManagerContract.at(stakeManagerAddress);
        await stakeManager.contract.methods.stakeForAddress(relayServer.getManagerAddress(), unstakeDelay).send({ from: this.devConfig.relayOwner, value: 1e18 });
        // not sure why: the line below started to crash on: Number can only safely store up to 53 bits
        // (and its not relayed - its a direct call)
        // await stakeManager.stakeForAddress(relayServer.getManagerAddress(), unstakeDelay, {
        //   from: this.devConfig.relayOwner,
        //   value: ether('1'),
        // })
        await stakeManager.authorizeHub(relayServer.getManagerAddress(), this.config.relayHubAddress, { from: this.devConfig.relayOwner });
        await this.contractInteractor.getWeb3().eth.sendTransaction({
            from: this.devConfig.relayOwner,
            to: relayServer.getManagerAddress(),
            value: 1e18
        });
        // @ts-ignore
        const relayInfo = await waitForRelay(relayServer.url + '/getaddr', 5000, (res) => {
            var _a;
            if (((_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.Ready) === true) {
                return {
                    relayManager: res.data.RelayServerAddress,
                    pctRelayFee: '0',
                    baseRelayFee: '0',
                    // @ts-ignore
                    relayUrl: relayServer.url
                };
            }
        });
        const devRelays = this.knownRelaysManager;
        devRelays.devRelay = relayInfo;
    }
    debug(...args) {
        if (this.config.verbose)
            console.log(...args);
    }
}
exports.DevRelayClient = DevRelayClient;
//# sourceMappingURL=DevRelayClient.js.map