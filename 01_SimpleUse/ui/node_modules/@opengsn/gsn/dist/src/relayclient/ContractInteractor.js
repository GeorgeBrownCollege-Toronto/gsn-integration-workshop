"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_1 = __importDefault(require("web3"));
const IPaymaster_1 = __importDefault(require("../common/interfaces/IPaymaster"));
const IRelayHub_1 = __importDefault(require("../common/interfaces/IRelayHub"));
const ITrustedForwarder_1 = __importDefault(require("../common/interfaces/ITrustedForwarder"));
const IStakeManager_1 = __importDefault(require("../common/interfaces/IStakeManager"));
const IRelayRecipient_1 = __importDefault(require("../common/interfaces/IRelayRecipient"));
const utils_1 = require("../common/utils");
const ErrorReplacerJSON_1 = __importDefault(require("../common/ErrorReplacerJSON"));
// Truffle Contract typings seem to be completely out of their minds
const TruffleContract = require("@truffle/contract");
exports.RelayServerRegistered = 'RelayServerRegistered';
exports.StakeUnlocked = 'StakeUnlocked';
exports.HubUnauthorized = 'HubUnauthorized';
exports.StakePenalized = 'StakePenalized';
class ContractInteractor {
    constructor(provider, config) {
        this.web3 = new web3_1.default(provider);
        this.config = config;
        this.provider = provider;
        // @ts-ignore
        this.IPaymasterContract = TruffleContract({
            contractName: 'IPaymaster',
            abi: IPaymaster_1.default
        });
        // @ts-ignore
        this.IRelayHubContract = TruffleContract({
            contractName: 'IRelayHub',
            abi: IRelayHub_1.default
        });
        // @ts-ignore
        this.IForwarderContract = TruffleContract({
            contractName: 'ITrustedForwarder',
            abi: ITrustedForwarder_1.default
        });
        // @ts-ignore
        this.IStakeManager = TruffleContract({
            contractName: 'IStakeManager',
            abi: IStakeManager_1.default
        });
        // @ts-ignore
        this.IRelayRecipient = TruffleContract({
            contractName: 'IRelayRecipient',
            abi: IRelayRecipient_1.default
        });
        this.IStakeManager.setProvider(this.provider, undefined);
        this.IRelayHubContract.setProvider(this.provider, undefined);
        this.IPaymasterContract.setProvider(this.provider, undefined);
        this.IForwarderContract.setProvider(this.provider, undefined);
        this.IRelayRecipient.setProvider(this.provider, undefined);
    }
    getProvider() { return this.provider; }
    getWeb3() { return this.web3; }
    async _init() {
        const chain = await this.web3.eth.net.getNetworkType();
        console.log('== chain=', chain);
        // @ts-ignore
        this.rawTxOptions = { chain: chain !== 'private' ? chain : null, hardfork: 'istanbul' };
    }
    // must use these options when creating Transaction object
    getRawTxOptions() {
        if (this.rawTxOptions == null) {
            throw new Error('_init not called');
        }
        return this.rawTxOptions;
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createRecipient(address) {
        return this.IRelayRecipient.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createPaymaster(address) {
        return this.IPaymasterContract.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createRelayHub(address) {
        return this.IRelayHubContract.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createForwarder(address) {
        return this.IForwarderContract.at(address);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _createStakeManager(address) {
        return this.IStakeManager.at(address);
    }
    async getForwarder(recipientAddress) {
        const recipient = await this._createRecipient(recipientAddress);
        return recipient.getTrustedForwarder();
    }
    async getSenderNonce(sender, forwarderAddress) {
        const forwarder = await this._createForwarder(forwarderAddress); // TODO: this is temoporary, add Forwarder API
        const nonce = await forwarder.getNonce(sender);
        return nonce.toString();
    }
    // TODO: currently the name is incorrect, as we call to 'canRelay'
    //  but the plan is to remove 'canRelay' and move all decision-making to Paymaster and Forwarder
    //  Also, as ARC does not return a value, `reverted` flag is unnecessary. This will be addressed soon.
    async validateAcceptRelayCall(relayRequest, signature, approvalData) {
        const paymaster = await this._createPaymaster(relayRequest.relayData.paymaster);
        const relayHub = await this._createRelayHub(this.config.relayHubAddress);
        const relayRequestAbiEncode = this.encodeABI(relayRequest, signature, approvalData);
        const calldataSize = relayRequestAbiEncode.length;
        const gasLimits = await paymaster.getGasLimits();
        const hubOverhead = await relayHub.getHubOverhead();
        const maxPossibleGas = utils_1.calculateTransactionMaxPossibleGas({
            gasLimits,
            hubOverhead: hubOverhead.toNumber(),
            relayCallGasLimit: relayRequest.gasData.gasLimit,
            calldataSize,
            gtxdatanonzero: this.config.gtxdatanonzero
        });
        let success;
        let returnValue;
        try {
            ({
                // @ts-ignore
                success,
                // @ts-ignore
                returnValue
            } = await relayHub.canRelay(relayRequest, maxPossibleGas, gasLimits.acceptRelayedCallGasLimit, signature, approvalData));
        }
        catch (e) {
            const message = e instanceof Error ? e.message : JSON.stringify(e, ErrorReplacerJSON_1.default);
            return {
                success: false,
                reverted: true,
                returnValue: `canRelay reverted (should not happen): ${message}`
            };
        }
        return {
            success,
            returnValue,
            reverted: false
        };
    }
    encodeABI(relayRequest, sig, approvalData) {
        // TODO: check this works as expected
        // @ts-ignore
        const relayHub = new this.IRelayHubContract('');
        return relayHub.contract.methods.relayCall(relayRequest, sig, approvalData).encodeABI();
    }
    topicsForManagers(relayManagers) {
        return Array.from(relayManagers.values(), (address) => `0x${address.replace(/^0x/, '').padStart(64, '0').toLowerCase()}`);
    }
    async getPastEventsForHub(names, extraTopics, options) {
        const relayHub = await this._createRelayHub(this.config.relayHubAddress);
        return this._getPastEvents(relayHub.contract, names, extraTopics, options);
    }
    async getPastEventsForStakeManager(names, extraTopics, options) {
        const stakeManager = await this._createStakeManager(this.config.stakeManagerAddress);
        return this._getPastEvents(stakeManager.contract, names, extraTopics, options);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _getPastEvents(contract, names, extraTopics, options) {
        const topics = [];
        const eventTopic = utils_1.event2topic(contract, names);
        topics.push(eventTopic);
        if (extraTopics.length > 0) {
            topics.push(extraTopics);
        }
        return contract.getPastEvents('allEvents', Object.assign({}, options, { topics }));
    }
    async getBlockNumber() {
        return this.web3.eth.getBlockNumber();
    }
    async sendSignedTransaction(rawTx) {
        return this.web3.eth.sendSignedTransaction(rawTx);
    }
    async estimateGas(gsnTransactionDetails) {
        return this.web3.eth.estimateGas(gsnTransactionDetails);
    }
    async getGasPrice() {
        return this.web3.eth.getGasPrice();
    }
    async getTransactionCount(relayWorker) {
        return this.web3.eth.getTransactionCount(relayWorker);
    }
}
exports.default = ContractInteractor;
//# sourceMappingURL=ContractInteractor.js.map