"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const ethereumjs_wallet_1 = __importDefault(require("ethereumjs-wallet"));
const Eip712Helper_1 = __importDefault(require("../common/EIP712/Eip712Helper"));
const eth_sig_util_1 = __importDefault(require("eth-sig-util"));
const utils_1 = require("../common/utils");
const web3_1 = __importDefault(require("web3"));
function toAddress(wallet) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return `0x${wallet.getAddress().toString('hex')}`;
}
class AccountManager {
    constructor(provider, chainId, config) {
        this.accounts = [];
        this.web3 = new web3_1.default(provider);
        this.chainId = chainId;
        this.config = config;
    }
    addAccount(keypair) {
        const wallet = ethereumjs_wallet_1.default.fromPrivateKey(keypair.privateKey);
        if (!utils_1.isSameAddress(toAddress(wallet), keypair.address)) {
            throw new Error('invalid keypair');
        }
        this.accounts.push(keypair);
    }
    newAccount() {
        const a = ethereumjs_wallet_1.default.generate();
        const keypair = {
            privateKey: a.privKey,
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            address: toAddress(a)
        };
        this.addAccount(keypair);
        return keypair;
    }
    // TODO: make forwarder part of RelayRequest, why is it dangling??
    async sign(relayRequest, forwarderAddress) {
        let signature;
        const signedData = Eip712Helper_1.default({
            chainId: this.chainId,
            verifier: forwarderAddress,
            relayRequest
        });
        const keypair = this.accounts.find(account => utils_1.isSameAddress(account.address, relayRequest.relayData.senderAddress));
        if (keypair != null) {
            signature = this._signWithControlledKey(keypair, signedData);
        }
        else {
            signature = await this._signWithProvider(signedData);
        }
        // Sanity check only
        let rec;
        try {
            // @ts-ignore
            rec = eth_sig_util_1.default.recoverTypedSignature_v4({
                data: signedData,
                sig: signature
            });
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Failed to sign relayed transaction for ${relayRequest.relayData.senderAddress}`);
        }
        if (!utils_1.isSameAddress(relayRequest.relayData.senderAddress.toLowerCase(), rec)) {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            throw new Error(`Internal RelayClient exception: signature is not correct: sender=${relayRequest.relayData.senderAddress}, recovered=${rec}`);
        }
        return signature;
    }
    // These methods is extracted to
    // a) allow different implementations in the future, and
    // b) allow spying on Account Manager in tests
    async _signWithProvider(signedData) {
        var _a, _b;
        return utils_1.getEip712Signature({
            web3: this.web3,
            methodSuffix: (_a = this.config.methodSuffix) !== null && _a !== void 0 ? _a : '',
            jsonStringifyRequest: (_b = this.config.jsonStringifyRequest) !== null && _b !== void 0 ? _b : false,
            dataToSign: signedData
        });
    }
    _signWithControlledKey(keypair, signedData) {
        // @ts-ignore
        return eth_sig_util_1.default.signTypedData_v4(keypair.privateKey, { data: signedData });
    }
}
exports.default = AccountManager;
//# sourceMappingURL=AccountManager.js.map