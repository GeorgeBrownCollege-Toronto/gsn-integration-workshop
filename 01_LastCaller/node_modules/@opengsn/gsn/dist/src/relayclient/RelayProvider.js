"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
const abi_decoder_1 = __importDefault(require("abi-decoder"));
const IRelayHub_1 = __importDefault(require("../common/interfaces/IRelayHub"));
const RelayClient_1 = __importDefault(require("./RelayClient"));
const GSNConfigurator_1 = require("./GSNConfigurator");
abi_decoder_1.default.addABI(IRelayHub_1.default);
class RelayProvider {
    /**
     * create a proxy provider, to relay transaction
     * @param overrideDependencies
     * @param relayClient
     * @param origProvider - the underlying web3 provider
     * @param gsnConfig
     */
    constructor(origProvider, gsnConfig, overrideDependencies, relayClient) {
        const config = GSNConfigurator_1.configureGSN(gsnConfig);
        this.host = origProvider.host;
        this.connected = origProvider.connected;
        this.origProvider = origProvider;
        this.config = config;
        this.origProviderSend = this.origProvider.send.bind(this.origProvider);
        this.relayClient = relayClient !== null && relayClient !== void 0 ? relayClient : new RelayClient_1.default(origProvider, gsnConfig, overrideDependencies);
        this._delegateEventsApi(origProvider);
    }
    _delegateEventsApi(origProvider) {
        // If the subprovider is a ws or ipc provider, then register all its methods on this provider
        // and delegate calls to the subprovider. This allows subscriptions to work.
        ['on', 'removeListener', 'removeAllListeners', 'reset', 'disconnect', 'addDefaultEvents', 'once', 'reconnect'].forEach(func => {
            // @ts-ignore
            if (origProvider[func] !== undefined) {
                // @ts-ignore
                this[func] = origProvider[func].bind(origProvider);
            }
        });
    }
    send(payload, callback) {
        if (this._useGSN(payload)) {
            if (payload.method === 'eth_sendTransaction') {
                this._ethSendTransaction(payload, callback);
                return;
            }
            if (payload.method === 'eth_getTransactionReceipt') {
                this._ethGetTransactionReceipt(payload, callback);
                return;
            }
        }
        this.origProviderSend(payload, (error, result) => {
            callback(error, result);
        });
    }
    _ethGetTransactionReceipt(payload, callback) {
        if (this.config.verbose) {
            console.log('calling sendAsync' + JSON.stringify(payload));
        }
        this.origProviderSend(payload, (error, rpcResponse) => {
            if (error != null) {
                callback(error);
                return;
            }
            if (rpcResponse == null || rpcResponse.result == null) {
                throw new Error('Empty JsonRpcResponse with no error message');
            }
            rpcResponse.result = this._getTranslatedGsnResponseResult(rpcResponse.result);
            callback(null, rpcResponse);
        });
    }
    _ethSendTransaction(payload, callback) {
        if (this.config.verbose) {
            console.log('calling sendAsync' + JSON.stringify(payload));
        }
        const gsnTransactionDetails = payload.params[0];
        this.relayClient.relayTransaction(gsnTransactionDetails)
            .then((relayingResult) => {
            if (relayingResult.transaction != null) {
                const jsonRpcSendResult = this._convertTransactionToRpcSendResponse(relayingResult.transaction, payload);
                callback(null, jsonRpcSendResult);
            }
            else {
                const message = `Failed to relay call. Results:\n${this._dumpRelayingResult(relayingResult)}`;
                if (this.config.verbose) {
                    console.error(message);
                }
                callback(new Error(message));
            }
        }, (reason) => {
            const reasonStr = reason instanceof Error ? reason.toString() : JSON.stringify(reason);
            callback(new Error(`Rejected relayTransaction call - should not happen. Reason: ${reasonStr}`));
        });
    }
    _convertTransactionToRpcSendResponse(transaction, request) {
        var _a;
        const txHash = transaction.hash(true).toString('hex');
        const hash = `0x${txHash}`;
        const id = (_a = (typeof request.id === 'string' ? parseInt(request.id) : request.id)) !== null && _a !== void 0 ? _a : -1;
        return {
            jsonrpc: '2.0',
            id,
            result: hash
        };
    }
    _getTranslatedGsnResponseResult(respResult) {
        const fixedTransactionReceipt = Object.assign({}, respResult);
        if (respResult.logs.length === 0) {
            return fixedTransactionReceipt;
        }
        const logs = abi_decoder_1.default.decodeLogs(respResult.logs);
        const canRelayFailed = logs.find((e) => e != null && e.name === 'CanRelayFailed');
        if (canRelayFailed !== null && canRelayFailed !== undefined) {
            const canRelayFailedReason = canRelayFailed.events.find((e) => e.name === 'reason');
            if (canRelayFailedReason !== undefined) {
                if (this.config.verbose) {
                    console.log(`canRelay failed: ${canRelayFailedReason.value}. changing status to zero`);
                }
                fixedTransactionReceipt.status = false;
            }
            return fixedTransactionReceipt;
        }
        const transactionRelayed = logs.find((e) => e != null && e.name === 'TransactionRelayed');
        if (transactionRelayed != null) {
            const transactionRelayedStatus = transactionRelayed.events.find((e) => e.name === 'status');
            if (transactionRelayedStatus !== undefined) {
                const status = transactionRelayedStatus.value.toString();
                // 0 signifies success
                if (status !== '0') {
                    if (this.config.verbose) {
                        console.log(`reverted relayed transaction, status code ${status}. changing status to zero`);
                    }
                    fixedTransactionReceipt.status = false;
                }
            }
        }
        return fixedTransactionReceipt;
    }
    _useGSN(payload) {
        var _a;
        if (payload.params[0] === undefined) {
            return false;
        }
        const gsnTransactionDetails = payload.params[0];
        const ret = (_a = gsnTransactionDetails === null || gsnTransactionDetails === void 0 ? void 0 : gsnTransactionDetails.useGSN) !== null && _a !== void 0 ? _a : true;
        return ret;
    }
    _dumpRelayingResult(relayingResult) {
        let str = `Ping errors (${relayingResult.pingErrors.size}):`;
        Array.from(relayingResult.pingErrors.keys()).forEach(e => {
            var _a, _b;
            const error = (_b = (_a = relayingResult.pingErrors.get(e)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            str += `\n${e} => ${error}\n`;
        });
        str += `Relaying errors (${relayingResult.relayingErrors.size}):\n`;
        Array.from(relayingResult.relayingErrors.keys()).forEach(e => {
            var _a, _b;
            const error = (_b = (_a = relayingResult.relayingErrors.get(e)) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            str += `${e} => ${error}`;
        });
        return str;
    }
    supportsSubscriptions() {
        return this.origProvider.supportsSubscriptions();
    }
    disconnect() {
        return this.origProvider.disconnect();
    }
    newAccount() {
        return this.relayClient.accountManager.newAccount();
    }
    addAccount(keypair) {
        this.relayClient.accountManager.addAccount(keypair);
    }
}
exports.RelayProvider = RelayProvider;
//# sourceMappingURL=RelayProvider.js.map